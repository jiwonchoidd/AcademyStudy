/**********************************************************************
* FILENAME :    CallSPFindID
*
* DESCRIPTION :
*               Simple ODBC example to SELECT data from a table via a stored
*               procedure where two arrays of parameters are used, one
*               containing FirstNames and one contining offsets into the
*               FirstNames array. As each FirstName is processed the matching
*               offset value is passed back as the stored procedure return
*               value. This can then be used by the calling program to identify
*               which element in the FirstNames array was used to generate the
*               results set.
*
*               The stored procedure has 3 parameters,
*               in the form :
*
*               {? = CALL Find_ByID(?, ?)}
*
*		If the record IDs array contains 111,222,333,444 and the
*		offsets array contains 0,1,2,3, we get, for each record ID, the
*		result set with the return value equal to the offset into the
*		record IDs array that produced the result set. For 111, we
*		0, 222 we get 1, etc. In that way we can tie a results set back
*		to the data that produced it.
*
* ODBC USAGE :
*               Calls DropProcedure (), CreateProcedure () and ListProcedure ()
*               to recreate and display the stored procedure 'Find_ByID'.
*               SQLSetStmtAttr - to set : SQL_ATTR_PARAMSET_SIZE
*                                         SQL_ATTR_PARAM_STATUS_PTR
*                                         SQL_ATTR_PARAMS_PROCESSED_PTR
*               SQLBindParameter - to bind 3 paramaters for the stored proc :
*                                  Param 1 - RetParam - proc return variable
*                                  Param 2 - pPersonIDs array
*                                  Param 3 - pPersonIXs array
*               SQLExecDirect    - to execute the stored procedure
*               Loops using SQLNumResultCols(), SQLFetch(), SQLRowCount()
*               and SQLMoreResults() to retrieve results sets generated by
*               stored procedure.
*/


#include "ODBCUtils.h"
#include "CallSpUtils.h"
#include <vector>
#include <string>
#include <tchar.h>
typedef std::basic_string<CHAR> T_STR;
typedef std::vector<T_STR>	T_STR_VECTOR;

#define PARAM_ARRAY_SIZE 20 // Number of params in param array
#define BUFFERSIZE 10000
char buf[255];
int main() 
{

	SQLHENV  henv = SQL_NULL_HENV;   	// Environment
	SQLHDBC  hdbc = SQL_NULL_HDBC;   	// Connection handle
	SQLHSTMT hstmt = SQL_NULL_HSTMT;  	// Statement handle
	SQLRETURN retcode;			// Return status

								// Return index pPersonIXs[param no] from stored Proc
	//unsigned char strCallSP[] = "{? = CALL Find_ByID(?, ?)}";
	TCHAR strCallSP[] = L"{? = CALL dbo.usp_free(?)}";

	TCHAR strProcName[] = L"Find_ByID";
	SQLSMALLINT columns; 		// Number of columns in result-set
	int i, count;

	SQLINTEGER  pPersonIDs[PARAM_ARRAY_SIZE] ={ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 };
	SQLINTEGER  pPersonIXs[PARAM_ARRAY_SIZE] ={ 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19 };

	SWORD  RetParam;
	SQLLEN cbRetParam;

	SQLUSMALLINT ParamStatusArray[PARAM_ARRAY_SIZE];
	SQLINTEGER   ParamsProcessed = 0;

	// Allocate an environment handle
	retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);
	CHECK_ERROR(retcode, "SQLAllocHandle(ENV)", henv, SQL_HANDLE_ENV);

	// Set ODBC Version
	retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION,(void *)SQL_OV_ODBC3, 0);
	CHECK_ERROR(retcode, "SQLSetEnvAttr(SQL_ATTR_ODBC_VERSION)",henv, SQL_HANDLE_ENV);

	// Allocate a connection handle
	retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);
	CHECK_ERROR(retcode, "SQLAllocHandle(SQL_HANDLE_DBC)",hdbc, SQL_HANDLE_DBC);

	// DSN
	TCHAR dsn[] = L"Driver={SQL Server};Server=shader.kr;Address=192.168.0.101,1433;Network=dbmssocn;Database=KGCAGAME;Uid=sa;Pwd=kgca!@34;";
	//retcode = SQLDriverConnect(hdbc, NULL, (SQLTCHAR *)dsn, sizeof(dsn),
	//	NULL, 0, NULL, 	SQL_DRIVER_NOPROMPT);
	//_stprintf(dsn, "%s", "Driver={SQL Server};Server=shader.kr;Address=192.168.0.101,1433;Network=dbmssocn;Database=KGCAGAME;Uid=sa;Pwd=kgca!@34;");
	SQLSMALLINT cbCon;
	SQLRETURN ret = SQLDriverConnect(hdbc,
		NULL,
		dsn, _countof(dsn),
		NULL, 0,
		&cbCon, SQL_DRIVER_NOPROMPT);

	//retcode = SQLConnect(hdbc, (SQLTCHAR *)dsn, SQL_NTS, 
	//	(SQLTCHAR *)"sa", SQL_NTS,
	//	(SQLTCHAR *)"kgca!@34", SQL_NTS);

	//retcode = SQLDriverConnect(hdbc, NULL, dsn, SQL_NTS,NULL, 0, NULL, SQL_DRIVER_COMPLETE);
	CHECK_ERROR(retcode, "SQLDriverConnect(DATASOURCE)",hdbc, SQL_HANDLE_DBC);

	retcode = DropProcedure(hdbc, strProcName);
	retcode = CreateProcedure(hdbc, strProcName);
	retcode = ListProcedure(hdbc, strProcName);

	// Allocate a statement handle
	retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);
	CHECK_ERROR(retcode, "SQLAllocHandle(SQL_HANDLE_STMT)",	hstmt, SQL_HANDLE_STMT);

	// Setup for parameter array processing
	retcode = SQLSetStmtAttr(hstmt, SQL_ATTR_PARAMSET_SIZE,	(SQLPOINTER)PARAM_ARRAY_SIZE, 0);
	retcode = SQLSetStmtAttr(hstmt, SQL_ATTR_PARAM_STATUS_PTR,	ParamStatusArray, PARAM_ARRAY_SIZE);
	retcode = SQLSetStmtAttr(hstmt, SQL_ATTR_PARAMS_PROCESSED_PTR,	&ParamsProcessed, 0);

	// Bind the output parameter to variable RetParam.
	retcode = SQLBindParameter(hstmt, 1, SQL_PARAM_OUTPUT, SQL_C_SSHORT,	SQL_INTEGER, 0, 0, &RetParam, 0, &cbRetParam);
	CHECK_ERROR(retcode, "SQLBindParameter(1)",	hstmt, SQL_HANDLE_STMT);

	// Bind array values of parameter 2 data in
	retcode = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_LONG,	SQL_INTEGER, 0, 0, pPersonIDs, 0, NULL);
	CHECK_ERROR(retcode, "SQLBindParameter(2)",	hstmt, SQL_HANDLE_STMT);

	// Bind array values of parameter 3 data in
	///retcode = SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_LONG,	SQL_INTEGER, 0, 0, pPersonIXs, 0, NULL);
	///CHECK_ERROR(retcode, "SQLBindParameter(3)",	hstmt, SQL_HANDLE_STMT);


	retcode = SQLExecDirect(hstmt, strCallSP, SQL_NTS);
	CHECK_ERROR(retcode, "SQLExecDirect(SQL_HANDLE_STMT)",	hstmt, SQL_HANDLE_STMT);

	printf("\nPersonID   Firstname     Surname    Address       City");
	printf("\n--------   ---------     -------    -------       ----\n");

	SQLLEN  indicator, RowCount;

	do {
		//https://www.ibm.com/support/knowledgecenter/ko/ssw_i5_54/cli/rzadpfnnxtres.htm
		//결과 세트의 열 수를 리턴합니다.
		//이 함수를 호출하기 전에 먼저 SQLPrepare() 또는 SQLExecDirect()를 호출해야 합니다.
		//이 함수를 호출한 후 SQLDescribeCol(), SQLColAttributes(), SQLBindCol() 또는 SQLGetData()를 호출할 수 있습니다.
		//SQLBindCol - 어플리케이션 변수에 열 바인드
		//SQLColAttributes - 열 속성 얻기
		//SQLDescribeCol - 열 속성 설명
		//SQLExecDirect - 명령문 직접 실행
		//SQLGetCol - 결과 세트 행의 한 열을 검색
		//SQLPrepare - 명령문 준비

		retcode = SQLNumResultCols(hstmt, &columns);
		CHECK_ERROR(retcode, "SQLNumResultCols()", hstmt, SQL_HANDLE_STMT);

		SQLTCHAR        colname[50] = { 0, };
		SQLSMALLINT     coltype;
		SQLSMALLINT     colnamelen;
		SQLULEN     precision;
		SQLSMALLINT     scale;
		std::vector<SQLSMALLINT> typeList;
		T_STR_VECTOR nameList;
		for (int iColmn = 0; iColmn < columns; iColmn++)
		{
			SQLDescribeCol(hstmt, iColmn + 1, colname, sizeof(colname),
				&colnamelen, &coltype, &precision, &scale, NULL);
			std::string  data = (char*)colname;
			nameList.emplace_back(std::move(data));
			//memset(colname, 0, 50);
			typeList.push_back(coltype);
		}
		if (columns > 0) 
		{
			printf("\nRows ...");
			while (SQLFetch(hstmt) != SQL_NO_DATA) 
			{
				// Loop through the columns
				memset(buf, ' ', 255);
				printf("\n");
				for (i = 1; i <= columns; i++) 
				{
					if (typeList[i - 1] == SQL_LONGVARBINARY)
					{
						FILE* pfile = fopen("IMAGE.bmp", "wb");
						char    smallbuffer[3000] = { 0, };
						do {
							retcode = SQLGetData(
								hstmt,
								i,          // The value of the token is the ordinal
								SQL_C_BINARY,
								smallbuffer,            // A small buffer
								sizeof(smallbuffer),
								&indicator);               // How much data we can get

							if (indicator > sizeof(smallbuffer)) // Full buffer
							{
								fwrite(smallbuffer, sizeof(char), sizeof(smallbuffer), pfile);
							}
							else // Partial buffer on last SQLGetData
							{
								fwrite(smallbuffer, sizeof(char), indicator, pfile);
							}
						} while (retcode == SQL_SUCCESS_WITH_INFO);
						fclose(pfile);
					}
					else
					{
						// retrieve column data as a string
						retcode = SQLGetData(hstmt, i, SQL_C_CHAR, buf, 255, &indicator);

						if (SQL_SUCCEEDED(retcode))
						{
							/* SQL data type codes */
							//#define SQL_UNKNOWN_TYPE    0
							//#define SQL_CHAR            1
							//#define SQL_NUMERIC         2
							//#define SQL_DECIMAL         3
							//#define SQL_INTEGER         4
							//#define SQL_SMALLINT        5
							//#define SQL_FLOAT           6
							//#define SQL_REAL            7
							//#define SQL_DOUBLE          8
							//#if (ODBCVER >= 0x0300)
							//#define SQL_DATETIME        9
							//#endif
							//#define SQL_VARCHAR         12
							//
							//						/* One-parameter shortcuts for date/time data types */
							//#if (ODBCVER >= 0x0300)
							//#define SQL_TYPE_DATE       91
							//#define SQL_TYPE_TIME       92
							//#define SQL_TYPE_TIMESTAMP  93
							//#endif
							char* pBuffer = 0;
							// Handle null columns
							if (indicator == SQL_NULL_DATA)
								strcpy(buf, "NULL");
							pBuffer = rtrim(buf, ' ');
							printf("%s ", pBuffer);
						}
					}
				}
				printf("\n");
			}
			printf("\nEnd ...");
		}
		else 
		{
			// SQLRowCount returns number of rows affected by INSERT, UPDATE,
			// DELETE or (if supported by the driver) number of rows returned
			// by a SELECT
			retcode = SQLRowCount(hstmt, &RowCount);
			CHECK_ERROR(retcode, "SQLRowCount()", hstmt, SQL_HANDLE_STMT);
			printf("\nRecord ID offset was : %i\nRecord ID was : %i",RetParam, pPersonIDs[RetParam]);
		}

		if (columns == 0)
		{
			printf("\n-----------");
		}
		// SQLMoreResults는 결과 세트을 리턴하는 저장된 프로시듀어와 연관된 명령문 핸들에서 사용할 수 있는 추가 정보가 더 있는지 판별합니다.
		// 모든 결과 세트가 처리되었으면 SQLMoreResults()는 SQL_NO_DATA_FOUND를 리턴합니다.
		// SQL_CLOSE 또는 SQL_DROP 옵션으로 SQLFreeStmt()를 호출하면 이 명령문 핸들 가운데 지연 중인 모든 집합이 삭제됩니다.
	} while ((retcode = SQLMoreResults(hstmt)) == SQL_NO_DATA_FOUND);// SQL_SUCCESS);

	// After SQLMoreResults() returns SQL_NO_DATA == SQL_NO_DATA_FOUND,
	if (retcode == SQL_NO_DATA && columns>0) 
	{
		printf("\nRecord ID offset was : %i\nRecord ID was : %i",
			RetParam, pPersonIDs[RetParam]);
		printf("\n-----------");
	}
	
	// Get the SQL_LONG column.  
	//SWORD cntr = 1;
	//UCHAR Data[BUFFERSIZE];
	//SDWORD cbBatch = (SDWORD)sizeof(Data) - 1;
	//SQLLEN cbTxtSize;

	//// Clear data array.  
	//for (cntr = 0; cntr < BUFFERSIZE; cntr++)	Data[cntr] = 0x00;

	//while ((retcode = SQLGetData(hstmt, 1, SQL_C_CHAR, Data, cbBatch, &cbTxtSize)) != SQL_NO_DATA)
	//{
	//	printf("GetData iteration %d, pcbValue = %d,\n", cntr++, cbTxtSize);
	//	printf("Data = %s\n\n", Data);

	//	if ((retcode != SQL_SUCCESS) && (retcode != SQL_SUCCESS_WITH_INFO)) 
	//	{
	//		printf("GetData(hstmt1) Failed\n\n");
	//		Cleanup();
	//		return(9);
	//	}
	//}

	
	//free(buf);
	// Free handles
	// Statement
	if (hstmt != SQL_NULL_HSTMT)
		SQLFreeHandle(SQL_HANDLE_STMT, hstmt);

	// Connection
	if (hdbc != SQL_NULL_HDBC) {
		SQLDisconnect(hdbc);
		SQLFreeHandle(SQL_HANDLE_DBC, hdbc);
	}

	// Environment
	if (henv != SQL_NULL_HENV)
		SQLFreeHandle(SQL_HANDLE_ENV, henv);
	printf("\nComplete.\n");
	return 0;
}
//
//// compile with: odbc32.lib  
//#include <stdio.h>  
//#include <string.h>  
//#include <windows.h>  
//#include <sql.h>  
//#include <sqlext.h>  
//#include <odbcss.h>  
//
//#define TEXTSIZE  12000  
//#define MAXBUFLEN 256  
//
//SQLHENV henv = SQL_NULL_HENV;
//SQLHDBC hdbc1 = SQL_NULL_HDBC;
//SQLHSTMT hstmt1 = SQL_NULL_HSTMT;
//
//void Cleanup() {
//	if (hstmt1 != SQL_NULL_HSTMT)
//		SQLFreeHandle(SQL_HANDLE_STMT, hstmt1);
//
//	if (hdbc1 != SQL_NULL_HDBC) {
//		SQLDisconnect(hdbc1);
//		SQLFreeHandle(SQL_HANDLE_DBC, hdbc1);
//	}
//
//	if (henv != SQL_NULL_HENV)
//		SQLFreeHandle(SQL_HANDLE_ENV, henv);
//}

//int main() {
//	RETCODE retcode;
//
//	// SQLBindParameter variables.  
//	SQLLEN cbTextSize, lbytes;
//
//	// SQLParamData variable.  
//	PTR pParmID;
//
//	// SQLPutData variables.  
//	UCHAR  Data[] =
//		"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
//		"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
//		"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
//		"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
//		"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
//		"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
//		"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
//		"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
//		"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
//		"abcdefghijklmnopqrstuvwxyz";
//
//	SDWORD cbBatch = (SDWORD)sizeof(Data) - 1;
//
//	// Allocate the ODBC environment and save handle.  
//	retcode = SQLAllocHandle(SQL_HANDLE_ENV, NULL, &henv);
//	if ((retcode != SQL_SUCCESS_WITH_INFO) && (retcode != SQL_SUCCESS)) {
//		printf("SQLAllocHandle(Env) Failed\n\n");
//		Cleanup();
//		return(9);
//	}
//
//	// Notify ODBC that this is an ODBC 3.0 app.  
//	retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER)SQL_OV_ODBC3, SQL_IS_INTEGER);
//	if ((retcode != SQL_SUCCESS_WITH_INFO) && (retcode != SQL_SUCCESS)) {
//		printf("SQLSetEnvAttr(ODBC version) Failed\n\n");
//		Cleanup();
//		return(9);
//	}
//
//	// Allocate ODBC connection handle and connect.  
//	retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc1);
//	if ((retcode != SQL_SUCCESS_WITH_INFO) && (retcode != SQL_SUCCESS)) {
//		printf("SQLAllocHandle(hdbc1) Failed\n\n");
//		Cleanup();
//		return(9);
//	}
//
//	// Sample uses Integrated Security, create SQL Server DSN using Windows NT authentication.   
//	retcode = SQLConnect(hdbc1, (UCHAR*)"AdventureWorks", SQL_NTS, (UCHAR*)"", SQL_NTS, (UCHAR*)"", SQL_NTS);
//	if ((retcode != SQL_SUCCESS) && (retcode != SQL_SUCCESS_WITH_INFO)) {
//		printf("SQLConnect() Failed\n\n");
//		Cleanup();
//		return(9);
//	}
//
//	// Allocate statement handle.  
//	retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc1, &hstmt1);
//	if ((retcode != SQL_SUCCESS) && (retcode != SQL_SUCCESS_WITH_INFO)) {
//		printf("SQLAllocHandle(hstmt1) Failed\n\n");
//		Cleanup();
//		return(9);
//	}
//
//	// Set parameters based on total data to send.  
//	lbytes = (SDWORD)TEXTSIZE;
//	cbTextSize = SQL_LEN_DATA_AT_EXEC(lbytes);
//
//	// Bind the parameter marker.  
//	retcode = SQLBindParameter(hstmt1,           // hstmt  
//		1,                // ipar  
//		SQL_PARAM_INPUT,  // fParamType  
//		SQL_C_CHAR,       // fCType  
//		SQL_LONGVARCHAR,  // FSqlType  
//		lbytes,           // cbColDef  
//		0,                // ibScale  
//		(VOID *)1,        // rgbValue  
//		0,                // cbValueMax  
//		&cbTextSize);     // pcbValue  
//
//	if ((retcode != SQL_SUCCESS) && (retcode != SQL_SUCCESS_WITH_INFO)) {
//		printf("SQLBindParameter Failed\n\n");
//		Cleanup();
//		return(9);
//	}
//
//	// Execute the command.  
//	retcode =
//		SQLExecDirect(hstmt1, (UCHAR*)"INSERT INTO emp4 VALUES('Paul Borm', 46,'1950-11-12 00:00:00', ?)", SQL_NTS);
//	if ((retcode != SQL_SUCCESS) && (retcode != SQL_NEED_DATA) && (retcode != SQL_SUCCESS_WITH_INFO)) {
//		printf("SQLExecDirect Failed\n\n");
//		Cleanup();
//		return(9);
//	}
//
//	// Check to see if NEED_DATA; if yes, use SQLPutData.  
//	retcode = SQLParamData(hstmt1, &pParmID);
//	if (retcode == SQL_NEED_DATA) {
//		while (lbytes > cbBatch) {
//			SQLPutData(hstmt1, Data, cbBatch);
//			lbytes -= cbBatch;
//		}
//		// Put final batch.  
//		retcode = SQLPutData(hstmt1, Data, lbytes);
//	}
//
//	if ((retcode != SQL_SUCCESS) && (retcode != SQL_SUCCESS_WITH_INFO)) {
//		printf("SQLParamData Failed\n\n");
//		Cleanup();
//		return(9);
//	}
//
//	// Make final SQLParamData call.  
//	retcode = SQLParamData(hstmt1, &pParmID);
//	if ((retcode != SQL_SUCCESS) && (retcode != SQL_SUCCESS_WITH_INFO)) {
//		printf("Final SQLParamData Failed\n\n");
//		Cleanup();
//		return(9);
//	}
//
//	// Clean up.  
//	SQLFreeHandle(SQL_HANDLE_STMT, hstmt1);
//	SQLDisconnect(hdbc1);
//	SQLFreeHandle(SQL_HANDLE_DBC, hdbc1);
//	SQLFreeHandle(SQL_HANDLE_ENV, henv);
//}