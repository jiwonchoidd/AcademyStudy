#include "astar.h"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// ASTAR() ////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ASTAR::ASTAR(int  TMP[COLS][ROWS],int cols,int rows)
{
   Stack = ( STACK* )calloc(1,sizeof( STACK ));
   CHECKPATH = FALSE;
   OPEN = NULL;
   CLOSED = NULL;
   PATH = NULL;
   Cols=cols,Rows=rows;
   TOTAL_TILES = Rows*Cols;
	for(int i=0;i<Cols;i++)
	for(int j=0;j<Rows;j++)
	{
		TileMap[i][j]=TMP[i][j];
	}
    
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// ~ASTAR () ///////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ASTAR::~ASTAR()
{
   FreeNodes();
   free(Stack);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// NewPath ()//////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ASTAR::NewPath(int sx,int sy, int dx,int dy)
{
   if ( FreeTile(dx,dy)&&FreeTile(sx,sy) && (TileNum(sx,sy)!=TileNum(dx,dy)) )
   {
		FreeNodes(); 
   		FindPath(sx,sy,dx,dy);
   		return (CHECKPATH=TRUE);
   }
   else
  	   return (CHECKPATH=FALSE);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// NewPath2 ()//////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ASTAR::NewPath2(int sx,int sy, int dx,int dy,int x,int y)
{
   if ( FreeTile(dx,dy)&&FreeTile(sx,sy) && (TileNum(sx,sy)!=TileNum(dx,dy)) )
   {
		int temp=TileMap[y][x];
		TileMap[y][x]=1;	
		FreeNodes(); 
   		FindPath(sx,sy,dx,dy);
		TileMap[y][x]=temp;
   		return (CHECKPATH=TRUE);
   }
   else
  	   return (CHECKPATH=FALSE);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// ReachedGoal ()//////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ASTAR::ReachedGoal(void) 
{                                      
   if ( !CHECKPATH ) return TRUE;  
   if ( PATH->Parent != NULL )  
   	return FALSE;            
   else
   	return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// TileSize ()/////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ASTAR::TileNum(int x, int y)
{
	return((y>>SHIFT)*Cols + (x>>SHIFT));
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// FreeTile ()//////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ASTAR::FreeTile(int x, int y)
{
	return(!TileMap[(y>>SHIFT)][x>>SHIFT]);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// FreeNodes ()////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ASTAR::FreeNodes(void)
{
  	NODE *Node, *OldNode;

   if ( OPEN != NULL )
   {
   	Node = OPEN->NextNode;
   	while ( Node != NULL )
	   {
      	OldNode = Node;
      	Node = Node->NextNode;
         free(OldNode);
	   }
   }
   if ( CLOSED != NULL )
   {
   	Node = CLOSED->NextNode;
   	while ( Node != NULL )
      {
         OldNode = Node;
      	Node = Node->NextNode;
     	   free(OldNode);
	   }
   }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// FindPath ()/////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ASTAR::FindPath(int sx, int sy, int dx, int dy)
{
	int TileNumDest,MAXCOUNT;
	int MaxTry=0,count=0;
	NODE *Node, *BestNode;
	MAXCOUNT=(abs(dx-sx)*Rows)+(abs(dy-sy)*Cols)+1;       //최대 검색 횟수 지정 
   TileNumDest = TileNum(sx, sy);                         //(현)시작 타일 번호(TileNumDest) 
   OPEN=  ( NODE* )calloc(1,sizeof( NODE ));
   CLOSED=( NODE* )calloc(1,sizeof( NODE ));
   Node=  ( NODE* )calloc(1,sizeof( NODE ));
   Node->g = 0;                                           // 거리함수 (깊이가 됨)
   Node->h = (dx-sx)*(dx-sx) + (dy-sy)*(dy-sy);           // 목표함수 (목표까지의 거리공식이 적용됨 )   시작 -> 목표가 아니라 목표 -> 시작 거리를 구함.
   Node->f = Node->g+Node->h;                             // 평가함수(거리함수 + 목표 함수 ) 
   Node->NodeNum = TileNum(dx, dy);                       // 목표 타일 번호 (NodeNum) 
   Node->x = dx;                                          // 목표타일의 x 좌표 저장 
   Node->y = dy;                                          // 목표타일의 y 좌표 저장  
   OPEN->NextNode=Node;                                   // 오픈 노드에 현 노드의 정보를 연결한다.(오픈노드에 삽입)
   while(1)
   {
		BestNode=ReturnBestNode();                        //최선의 노드를 리턴받아서(오픈 노드에는 항상 최선의 노드가 저장 되어 있음.) BestNode에 대입.
		if(BestNode==NULL)                                //최선의 노드가 없으면 루틴을 빠져 나간다.(Null값을 대입하면 않된다.)
			return;
		if (BestNode->NodeNum == TileNumDest)             //현 베스트노드의 타일번호가  목표타일번호와 같으면 루틴을 빠져나간다.
	   		break;
		if(BestNode->g > MAXCOUNT)                        //최대 반복검색 횟수보다 거리함수값이 크면 루틴을 빠져 나간다. (무한정 기달릴 수가 없다.)
			break;
		DIRECTIONS(BestNode,sx,sy);                       //현 위치에서 갈수 있는 방향을 구하기 위해 현 정보를 인수로 넘겨준다.
   }  
   PATH = BestNode;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// ReturnBestNode ()///////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ASTAR::NODE *ASTAR::ReturnBestNode(void)
{
   NODE *tmp;                                            //임시 노드 
   TCHAR message[128];

   if ( OPEN->NextNode == NULL )                         //만약 오픈노드에 아무 정보도 없으면 실행을 끝낸다.처음 노드가 삽입되기 때문에 항상 노드가 들어 있으며 널이 들어 있을 때는 목표 번호가 
	                                                     //갈수 없는 타일일 경우가 된다.
   {
	  sprintf(message,"OPEN node Error");
		// MessageBox(0, message, "Error A*", MB_OK | MB_ICONERROR);
      PostQuitMessage(0);
	  return NULL;
   }
   tmp = OPEN->NextNode;                                //임시노드에 오픈노드의 다음노드를 대입한다.
   OPEN->NextNode = tmp->NextNode;                      //오픈 노드의 다음 노드를 삭제한다.(널 값이 대입)
   tmp->NextNode = CLOSED->NextNode;                    //임시노드에 널값을 대입.
   CLOSED->NextNode = tmp;                              //임시노드를 크로스 노드에 삽입한다.
                                                        //오픈노드에서 한 노드를 구하여 임시노드에 대입하고 오픈노드에서 그 노드를 삭제한다. 이후 크로스 노드에 대입하고 임시노드를 
                                                        //리턴값으로 돌려준다.
   return(tmp);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// DIRECTIONS ()///////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ASTAR::DIRECTIONS(NODE *BestNode, int dx, int dy) //directions 4방향 중 갈수 있는 타일을 검색한다.
                                                       //함수 호출시 sx,sy는 시작좌표가 되고 이 좌표가 dx,dy로 대입하여 넘어 온다. 
{
   int x, y;
		    // Right
   if ( FreeTile(x=BestNode->x+TILESIZE, y=BestNode->y) )              
        DIRECTIONS_SUCCESS(BestNode,x,y,dx,dy);                       //갈수 있는 타일이면 그 노드의 목표타일에서 시작타일까지의 갈수 있는 길을 구한다.
	  	    // Lower
   if ( FreeTile(x=BestNode->x, y=BestNode->y+TILESIZE) )
      DIRECTIONS_SUCCESS(BestNode,x,y,dx,dy);
	    // Left
   if ( FreeTile(x=BestNode->x-TILESIZE, y=BestNode->y) )
      DIRECTIONS_SUCCESS(BestNode,x,y,dx,dy);	 
			// Upper
   if ( FreeTile(x=BestNode->x, y=BestNode->y-TILESIZE) )
	    DIRECTIONS_SUCCESS(BestNode,x,y,dx,dy);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// DIRECTIONS_SUCCESS ()/////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ASTAR::DIRECTIONS_SUCCESS(NODE *BestNode,int x, int y, int dx, int dy)
{
   int g, TileNumS, c = 0;
   NODE *Old, *Successor;
   g = BestNode->g+1;	                                // 거리깊이는 항상 1씩 더해져야 한다. 
   TileNumS = TileNum(x,y);                             // 4방향중 갈수 있는 타일의 번호를 저장한다.
   if ( (Old=CheckOPEN(TileNumS)) != NULL )             //오픈노드에 있는 지를 검사한다. 없으면 널이 리턴된다.
   {
		for( c = 0; c < 4; c++)                         //노드에서 자식노드는 항상 4방향이므로 빈 자식노드에 
	   	if( BestNode->Child[c] == NULL )                //결국은 오픈노드에 들어 있는 노드가 인수로 넘어온 베스트노드와 같으므로 
	   		break;
		BestNode->Child[c] = Old;                       //배스트의 자식노드를 타일번호가 같은 old노드로 삽입한다.

		if ( g < Old->g )                               //만약 거리깊이가 old노드보다 작다면 올드노드의 부모는 당연히 베스트노드가 되어야 하며.
			                                            //작지 않다면 이미 부모노드의 역활을 하고 있는 것이다.     
		{
			Old->Parent = BestNode;
	   	Old->g = g;                                     //거리깊이는 현재으 거리깊이가 대입되면 된다.
	   	Old->f = g + Old->h;                            //평가함수도 마찬가지로 다시 구할수 있다.
		}
   }
   else if ( (Old=CheckCLOSED(TileNumS)) != NULL ) 
   {
   for( c = 0; c< 4; c++)
		if ( BestNode->Child[c] == NULL ) 
	   		break;
		BestNode->Child[c] = Old;

		if ( g < Old->g )  
		{
	   	    Old->Parent = BestNode;
	   	    Old->g = g;
	   	    Old->f = g + Old->h;
	   	    CHILD_NODE_CREATE(Old);
       }
   }
   else
   {
		Successor = ( NODE* )calloc(1,sizeof( NODE ));       //처음 실행시는 항상 이 루틴이 실행되면 
		Successor->Parent = BestNode;                        //갈수 있는 4방향을 체크하여 들어 오것이므로 베스트 노드를 부모 노드로 하여야 한다.  목표<-부모(successor)<--( ? )<- ===> 시작노드 
		Successor->g = g;                                    //거리함수 (깊이)
		Successor->h = (x-dx)*(x-dx) + (y-dy)*(y-dy);        //목표거리함수  
		Successor->f = g+Successor->h;                       //평가 함수 
		Successor->x = x;                                    //x 좌표 저장 
		Successor->y = y;                                    //y 좌표 저장 
		Successor->NodeNum = TileNumS;                       //타일번호가 대입된다.
		Insert(Successor);                                   //스택에 삽입하여 둔다. 이유는 갈수 있는 방향이 1곳만이 아니기 때문이다.
		for( c =0; c < 4; c++)
			if ( BestNode->Child[c] == NULL )                //일단 자식노드중 들어 갈수 있는지 판단한다.
	  		    break;
		BestNode->Child[c] = Successor;                      //빈 자식노드에 삽입한다.
   }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// CheckOPEN ()////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ASTAR::NODE *ASTAR::CheckOPEN(int tilenum)
{
   NODE *tmp;                                          //임시 노드 
   tmp = OPEN->NextNode;                               //오픈노드에 들어 있는 모든노드를 인수로 넘어온 번호와 비교하여 같다면 그 노드를 리턴한다.
   while ( tmp != NULL )
   {
		if ( tmp->NodeNum == tilenum )
	   	return (tmp);
		else
	  		tmp = tmp->NextNode;                       //오픈노드의 다음노드를 비교하기 위하여 임시노드에 대입하여 루틴을 돈다.
   }
   return(NULL);                                       //만약 오픈노드의 노드들과 비교하였으나 타일번호가 같은 것이 없으면 널을 리턴한다.
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// CheckCLOSED ()//////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ASTAR::NODE *ASTAR::CheckCLOSED(int tilenum)
{
   NODE *tmp;
   tmp = CLOSED->NextNode;
   while ( tmp != NULL )
   {
		if ( tmp->NodeNum == tilenum )
      	return(tmp);
		else
	   	tmp = tmp->NextNode;
   }
   return(NULL);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Input ()////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ASTAR::Insert(NODE *Successor)
{
   NODE *tmp1, *tmp2;
   int f;
   if ( OPEN->NextNode == NULL )
   {
		OPEN->NextNode = Successor;                // 중요 오픈 노드에 삽입하여 다음 비교시 참조되도록 한다.
		return;                                    
   }
   f = Successor->f;                               //만약 비워있지 않으면      오픈노드에 있는 노드들중에 오름차순정렬하여 재 배치한다.
   tmp1 = OPEN;
   tmp2 = OPEN->NextNode;
   while ( (tmp2 != NULL) && (tmp2->f < f) )       
   {
   	 tmp1 = tmp2;
       tmp2 = tmp2->NextNode;
   }
   Successor->NextNode = tmp2;
   tmp1->NextNode = Successor;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// CHILD_NODE_CREATE ()////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ASTAR::CHILD_NODE_CREATE(NODE *Old)
{
   int c, g;
   NODE *Child,*Father;
   g = Old->g;         
   for ( c = 0; c < 4; c++)
   {
   	if ( (Child=Old->Child[c]) == NULL )   
          break;
		if ( g+1 < Child->g)
		{
	   	 Child->g = g+1;
	   	 Child->f = Child->g + Child->h;
	  	    Child->Parent = Old;           
	       Push(Child);                
		}    
   }
   while ( Stack->NextStackPtr != NULL )
   {
		Father = Pop();
		for (c = 0; c<4; c++)
		{
	   	if ( (Child=Father->Child[c]) == NULL ) 
	  			break;
	      if ( Father->g+1 < Child->g ) 
	  		{                          
	      	Child->g = Father->g+1;
	    		Child->f = Child->g+Child->h;
	    		Child->Parent = Father;
	    		Push(Child);
	      }
	   }
   }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Push ()/////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ASTAR::Push(NODE *Node)
{
   STACK *tmp;
   tmp =( STACK* )calloc(1,sizeof( STACK ));
   tmp->NodePtr = Node;
   tmp->NextStackPtr = Stack->NextStackPtr;
   Stack->NextStackPtr = tmp;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Pop ()//////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ASTAR::NODE *ASTAR::Pop(void)
{
   NODE *tmp;
   STACK *tmpSTK;
   tmpSTK = Stack->NextStackPtr;
   tmp = tmpSTK->NodePtr;
   Stack->NextStackPtr = tmpSTK->NextStackPtr;
   free(tmpSTK);
   return(tmp);
}
