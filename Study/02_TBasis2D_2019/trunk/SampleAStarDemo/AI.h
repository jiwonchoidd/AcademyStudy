////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// AI.H ///////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef  AI_H
#define  AI_H
#include <ddraw.h>
#include <time.h>
#include "Map.h"                              //함수 정의 및 맵정의 헤더파일 
#include "astar.h"                            //A*  헤더파일  

#define	 TileSize 16                          // 타일 사이즈  
#define  random(num) (int)((long)rand()*(num))             // 적 유닛의 위치를 랜덤하게 위치 시키기 위해서.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// Variable ////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HWND MainHwnd;
LPDIRECTDRAW7         DirectOBJ;        //객체생성 
LPDIRECTDRAWSURFACE7  RealScreen;       //전면
LPDIRECTDRAWSURFACE7  BackScreen;       //후면 
LPDIRECTDRAWSURFACE7  UnitImage;        //플레이어 유닛  
LPDIRECTDRAWSURFACE7  BackImage;        //바탕화면 1
LPDIRECTDRAWSURFACE7  BackImage2;       //바창화면 2  
LPDIRECTDRAWSURFACE7  Units;            //적 유닛 3,4 
LPDIRECTDRAWSURFACE7  UnitImage2;       //적 유닛 1,2   
LPDIRECTDRAWSURFACE7  EndImage; 
LPDIRECTDRAWSURFACE7  StartImage; 


DDSURFACEDESC2        ddsd;
WORD                 *ScreenPointer;    //후면SURFACE 포인터 (직접출력)
DWORD		Pitch;               

static int attack;
static int plag,tmp,chk2,temp,startindex;//,STARTCLOCK,ENDCLOCK;                             // 각종 플레그 변수 
static WORD MouseX,MouseY,nextdestx,nextdesty,nextx,nexty;      // 마우스 좌표와 A* 다음 좌표의 x,y 위치 저장 변수  
static int MOUSEX=560;               //임시 마우스 클릭 좌표 X
static int MOUSEY=16;              //임시 마우스 클릭 좌표 Y
static int HITCOUNT=50;
int        TargetX,TargetY,xx,yy,nx,ny;                        //길찾기시 유닛의 현위치 저장 임시 변수  

ASTAR		*Astar;
ASTAR       *Astar2;
ASTAR       *Astar3;

//RIGHT_HAND  *Hand;

int			Tile_Map[COLS][ROWS];                               //맵의 2차원 배열  

RECT Srect;	

static int TAX=320,TAY=16;       //플레이어의 자동 이동 좌표 초기화 
static int TBX=320,TBY=16;
static int TCX=320,TCY=16;
static int TDX=320,TDY=16;
static int TEX=320,TEY=16;
static int TA,TB,TC,TD,TE;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////// GameMode() ////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL GameMode( )
{  
	// 장막의 타일로 생성 초기화 
    for(int i=0;i<COLS;i++)
	for(int j=0;j<ROWS;j++)
	{
		Tile_Map[i][j]=MapData[i][j];
		MapSecond[i][j]=1;
	}
	return TRUE;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// InitCreate() //////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 플레이어 유닛의 자동처리시 이동할 좌표를 인수로 하여 각 목표좌표를 분기됨 
// flag : 목표이동 번호 
// x    : 적 유닛의 x 좌표.
// y    : 적 유닛의 y 좌표.

void InitCreate(int flag,int x,int y)
{
	switch(flag)
	{
		case 0:	if(Astar->NewPath2(UNITS[0].Px,UNITS[0].Py,TAX,TAY,x,y) )
				{
					Astar->PathNextNode();
					nextdestx=Astar->NodeGetX();
					nextdesty=Astar->NodeGetY();
					chk2=1;
				}
				break;
		case 1:	if(Astar->NewPath2(UNITS[0].Px,UNITS[0].Py,TBX,TBY,x,y ) )
				{
					Astar->PathNextNode();
					nextdestx=Astar->NodeGetX();
					nextdesty=Astar->NodeGetY();
					chk2=1;
				}
				break;
		case 2:	if(Astar->NewPath2(UNITS[0].Px,UNITS[0].Py,TCX,TCY,x,y ) )
				{
					Astar->PathNextNode();
					nextdestx=Astar->NodeGetX();
					nextdesty=Astar->NodeGetY();
					chk2=1;
				}
				break;
		case 3:	if(Astar->NewPath2(UNITS[0].Px,UNITS[0].Py,TDX,TDY,x,y ) )
				{
					Astar->PathNextNode();
					nextdestx=Astar->NodeGetX();
					nextdesty=Astar->NodeGetY();
					chk2=1;
				}
				break;
		case 4:	if(Astar->NewPath2(UNITS[0].Px,UNITS[0].Py,TEX,TEY,x,y ) )
				{
					Astar->PathNextNode();
					nextdestx=Astar->NodeGetX();
					nextdesty=Astar->NodeGetY();
					chk2=1;
				}
				break;
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Fail() /////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//모든 유닛의 초기 위치 지정.

void INIT_UNITS_POINT_XY()
{
	UNITS[0].Px=320,UNITS[0].Py=16;		//플레이어 
	
	UNITS[1].Px=144,UNITS[1].Py=160;	//UNIT1
	UNITS[2].Px=16,UNITS[2].Py=32;		//UNIT2

	UNITS[3].Px=480,UNITS[3].Py=64;		//UNIT3
	UNITS[4].Px=480,UNITS[4].Py=400;	//UNIT4
	
	//플레이어 유닛 주변 6개 타일의 장막을 거둔다.
	for(int c=UNITS[0].Py-TileSize*4 ; c<=UNITS[0].Py+TileSize*4 ; c++)
	for(int r=UNITS[0].Px-TileSize*4 ; r<=UNITS[0].Px+TileSize*4 ; r++)
	{
		int x1=c>>SHIFT;
		int y1=r>>SHIFT;
		if(x1 >= 0 && x1 < 30 && y1 >=0 && y1 < 40)                   // 최소한 0보다는 커야하고 x 는 30타일 , y 는 40 타일를 사이로 지정되야함. 
			MapSecond[x1][y1]=0;
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Fail() /////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 다이렉트 객체 생성 및 각종 설정 에러시  샐행됨.  

BOOL Fail( HWND hwnd )

{
    ShowWindow( hwnd, SW_HIDE );
    MessageBox( hwnd, L"Error", L"GAME", MB_OK );
    DestroyWindow( hwnd );
    return FALSE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// ReleaseAll() //////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
// 모든 객체를 제거한다.

void ReleaseAll( void )
{
    if ( DirectOBJ != NULL )
    {
        if ( RealScreen != NULL )
        {
            RealScreen->Release();
            RealScreen = NULL;
        }
        DirectOBJ->Release();
        DirectOBJ = NULL;
    }
	delete Astar;
	//delete Hand;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// LockScreen() ///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 후면 Surface 의 포인터를 얻는다.

void LockScreen( void )
{
    memset( &ddsd, 0, sizeof(ddsd) );
    ddsd.dwSize = sizeof(ddsd);
    BackScreen->Lock( NULL, &ddsd, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL );
    ScreenPointer = (WORD *)ddsd.lpSurface;
    BackScreen->Unlock( NULL );
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// UnInitDirectDraw() ///////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// DirectDraw 해제 

HRESULT UnInitDirectDraw(void)
{
	if(DirectOBJ!= NULL)
	{
		if(RealScreen!= NULL)
		{
			if(RealScreen->Release()==DD_OK)
		         RealScreen=NULL;
			if(DirectOBJ->Release()==DD_OK)
				DirectOBJ=NULL;
		}
	}	
	return TRUE;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// CheckMap() ///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 현 top : x , left : y 좌표의 타일위치가 막힌 타일인지를 검사 
// 만약 막혀 있으면 0를 리턴함. 

int  CheckMap(int top,int left)
{
	if(MapData[left>>SHIFT][top>>SHIFT]==1)//맵은 배열과 같다.좌표를 X,Y로 변환 타일사이즈로 나눈다.
		return 0;
	return 1;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// BackTileDraw() //////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 배경타일을 출력함.

void BackTileDraw(int chk)
{
	
	for (int i = 0; i < 7; i++)
	{
		for (int j = 34; j < 40; j++)
		{
			MapSecond[i][j] = 0;
		}
	}

	for(int mapy=0;mapy<COLS;mapy++)
	{
		for(int mapx=0;mapx<ROWS;mapx++)
		{
			if(chk==0)
			{
				if(MapData[mapy][mapx]==1)//00 01 02 03....
				{
					SetRect(&Srect,0,0,TileSize,TileSize);
					BackScreen->BltFast(mapx*TileSize,mapy*TileSize,BackImage,&Srect,DDBLTFAST_WAIT);		//00 10 20 30....
				}
				else if(MapData[mapy][mapx]==0)
				{
					SetRect(&Srect,0,0,TileSize,TileSize);
					BackScreen->BltFast(mapx*TileSize,mapy*TileSize,UnitImage,&Srect,DDBLTFAST_WAIT);
				}
				else
				{
					SetRect(&Srect,0,0,TileSize,TileSize);
					BackScreen->BltFast(mapx*TileSize,mapy*TileSize,Units,&Srect,DDBLTFAST_WAIT);
				}
			}
			else
			{
				if(MapSecond[mapy][mapx]==1)//00 01 02 03....
				{
					SetRect(&Srect,96,0,96+TileSize,TileSize);
					BackScreen->BltFast(mapx*TileSize,mapy*TileSize,UnitImage2,&Srect,DDBLTFAST_WAIT);
				}
				else 
				{	
					RECT Srect,Drect;
					int Frame=1;
					Srect.left     =   600;
					Srect.top      =   0;
					Srect.right    =   700;
					Srect.bottom   =   70;
   					SetRect(&Drect,mapx*TileSize,mapy*TileSize,mapx*TileSize+TileSize,mapy*TileSize+TileSize);
					BackScreen->Blt(&Drect,UnitImage2,&Srect,DDBLT_KEYSRC|DDBLT_WAIT,NULL);
				}
			
			}
			
		}	
	}
	
}	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// DISTANCE_COLLSION() ////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 리턴 : 1 = 적 유닛 1와 충돌 
// 리턴 : 2 = 적 유닛 2와 충돌 
// 리턴 : 0 = 충돌 없음.

//타일의 중심점을 구하여 거리를 계산한다.
//플레이어 유닛 (x,y), 적 유닛 1 (x1,y1) , 적 유닛 2 (x2,y2)
//매크로로 지정되어 있는 DISTANCE 와 비교하여 지정 거리보다 유닛들간의 거리가 작은면 충돌로 간주한다.


int DISTANCE_COLLSION(int x,int y,int x1,int y1,int x2,int y2)
{
	int px,py,px1,py1,px2,py2;

	px=(x+TileSize)/2;			//플레이어의 중점 X        
	py=(y+TileSize)/2;          //플레이엉의 중점 Y
	 
	px1=(x1+TileSize)/2;		//적유닛 1의 중점 X 좌표 
	py1=(y1+TileSize)/2;        //적유닛 1의 중점 Y 좌표 
	
	px2=(x2+TileSize)/2;		//적유닛 2의 중점 X 좌표 
	py2=(y2+TileSize)/2;		//적유닛 2의 중점 Y 좌표 
	
	// 지정 거리와 유닛 사이의 거리를 비교 한다. 
	if(abs(px-px1) <  DISTANCE && abs(py-py1) < DISTANCE)
			return 1;
	if(abs(px-px2) <  DISTANCE && abs(py-py2) < DISTANCE)
		return 2;
	
	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// CheckJun ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//리턴 :  0 = 충돌 
//리턴 :  1 = 충돌없음. 
//충돌 체크 : 겹쳐 있는지를 비교한다.
// 플레이어 , 유닛 1,2

int COLLISION(int playerx,int playery,int unitx,int unity,int px,int py)
{
	
	if(playerx+TileSize > unitx && playerx < unitx+TileSize && playery+TileSize > unity && playery < unity + TileSize)
		return 0;
	if(playerx+TileSize > px && playerx < px+TileSize && playery+TileSize > py && playery < py+TileSize)
		return 0;
	
	return 1;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// GAME_OVER_CHECK() ////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 모든 장막 비교

int  GAME_OVER_CHECK()
{
	for(int c=0; c<COLS ; c++)
	for(int r=0; r<ROWS ; r++)
	{
		if(MapSecond[c][r]!=0)    // 만약 단 1개의 타일이라도 거치지 않았으면 0을 리턴한다.(게임 계속됨.)
			return 0;
	}
	return 1;                     // 게임 종료. 
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// GAMEOVER() /////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 엔딩 화면 출력 

void GAMEOVER()
{
	RECT BackRect={0,0,640,480};
	BackScreen->BltFast(0,0,EndImage,&BackRect,DDBLTFAST_WAIT|DDBLTFAST_NOCOLORKEY);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////// GAME-AGAIN() //////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 충돌체크 후 시행
// tmp =  0 이면 현 플레이어의 2 타일 주변만 장막이 거친다. 그 외 지역은 장막이 됨.
// tmp =  1 이면 처음 시작 단계로 설정된다.  
// tmp =  2 이면 공격성공으로 적 유닛들이 시작위치로 돌아간다. 벗긴 타일은 그대로 유지 

void GAME_AGAIN(int tmp)
{
	if(tmp==0)
	{
		for(int i=0;i<COLS;i++)
		for(int j=0;j<ROWS;j++)
		{		MapSecond[i][j]=1;	
		}
		
		chk2=0;
		for(int c=UNITS[0].Py-TileSize*2 ; c<=UNITS[0].Py+TileSize*2 ; c++)
		for(int r=UNITS[0].Px-TileSize*2 ; r<=UNITS[0].Px+TileSize*2 ; r++)
		{
			int x1=c>>SHIFT;
			int y1=r>>SHIFT;
			if(x1 >= 0 && x1 < COLS && y1 >=0 && y1 < ROWS) 
			MapSecond[x1][y1]=0;
		}
	}
	else if(tmp==1)
	{
		HITCOUNT=0;
		for(int i=0;i<COLS;i++)
		for(int j=0;j<ROWS;j++)
		{
			MapSecond[i][j]=1;	
		}

		UNITS[0].Px=320;UNITS[0].Py=16;;chk2=0;
		for(int c=UNITS[0].Py-TileSize*2 ; c<=UNITS[0].Py+TileSize*2 ; c++) // 플레이어어 3 타일 주위의 장막을 없앤다.
		for(int r=UNITS[0].Px-TileSize*2 ; r<=UNITS[0].Px+TileSize*2 ; r++)
		{
			int x1=c>>SHIFT;
			int y1=r>>SHIFT;
			if(x1 >= 0 && x1 < COLS && y1 >=0 && y1 < ROWS) 
			MapSecond[x1][y1]=0;
		}
	}
	else
	{
		UNITS[1].Px=144,UNITS[1].Py=160;	//UNIT1
		UNITS[2].Px=16,UNITS[2].Py=32;		//UNIT2
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// CollisionSprite() ///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 충돌 스프라이트 

void CollisionSprite()
{
	
		static int Frame;
		int flagtmp=0;
		RECT Srect,Drect;
		while(1)
		{
			//RECT Srect,Drect;
			Srect.left     =   Frame * 100;
			Srect.top      =   0;
			Srect.right    =   Srect.left + 100;
			Srect.bottom   =   70;
			SetRect(&Drect,TargetX,TargetY,TargetX+TileSize,TargetY+TileSize);
			BackScreen->Blt(&Drect,UnitImage2,&Srect,DDBLT_KEYSRC|DDBLT_WAIT,NULL);
			if ( Frame > 4 ) 
			{
				Frame = 0;	
				flagtmp=1;
			}
			else
				Frame++;
			
			RealScreen -> Flip( NULL, DDFLIP_WAIT );
			if(flagtmp==1)
				break;
			
		}
		UNITS[2].Px=16;UNITS[2].Py=16;UNITS[1].Px=320;UNITS[1].Py=160;

}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// PaintText() //////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 유닛의 좌표를 상단에 추력한다.

void PaintText(int x,int y,TCHAR * string)
{
	HDC hdc;
	//HFONT ft;
	BackScreen->GetDC(&hdc);
	SetBkMode(hdc,TRANSPARENT);
	//ft=CreateFont(10,10,0,0,FW_HEAVY,true,FALSE,HANGEUL_CHARSET,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,DEFAULT_QUALITY,DEFAULT_PITCH,"굴림체");
	//SelectObject(hdc,ft);
	SetTextColor(hdc,RGB(255,255,255));
	TextOut(hdc,x,y,string, wcslen(string));
	//DeleteObject(ft);
	BackScreen->ReleaseDC(hdc);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// TileNnum() ///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 타일읠 맵 번호를 리턴한다.

int TileNum(int x, int y)
{
	return((y>>SHIFT)*ROWS + (x>>SHIFT));
}

#endif
